setwd("~/GitHub/QBIO499/HW9")
park = read.table("parkinsons_updrs.data")
dim(park)
park <- read.table("parkinsons_updrs.data")
park <- read.table("parkinsons_updrs.data")
park[7:22]
park[7:22,]
formula <- as.formula(paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+")))
glm.fit = glm((paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+")), data=park)
glm.fit = glm((paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+")) data=park)
glm.fit = glm((paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+"))), data=park)
fix(park)
park <- read.csv("parkinsons_updrs.data", headers=F)
park <- read.csv("parkinsons_updrs.data")
park
fix(park)
glm.fit = glm((paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+"))), data=park)
summary(glm.fit)
fix(park)
ff = regsubsets((paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+"))), data=park, method="forward")
library(leaps)
ff = regsubsets((paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+"))), data=park, method="forward")
formula <- as.formula((paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+"))))
formula
ff = regsubsets(formula, data=park, method="forward")
summary(ff)
glm.fit1 = glm(motor_UPDRS~PPE, data=park)
summary(glm.fit1)
cv.glm(park, glm.fit1, K=10)
library(boot)
cv.glm(park, glm.fit1, K=10)
$K
cv.glm(park, glm.fit1, K=10)$delta
plot(cv.glm(park, glm.fit1, K=10)$delta)
cv.glm(park, glm.fit1, K=10)$delta
cv.glm(park, glm.fit1, K=10)$delta
cv <- function(data, model){
# Randomly shuffle the data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds_
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fitB <- lm(model, data=trainData)
EMSE <- mean((data$motor_UPDRS - predict(lm.fitB, newdata = trainData))^2)
EMSE
}
}
cv(park, motor_UPDRS~PPE)
cv(park, motor_UPDRS~.)
cv <- function(data, model){
# Randomly shuffle the data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds_
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fitB <- lm(model, data=trainData)
EMSE <- mean((data$motor_UPDRS - predict(lm.fitB, newdata = testData))^2)
EMSE
}
}
cv(park, motor_UPDRS~.)
park2 <- park[sample(nrow(park)),]
folds <- cut(seq(1, nrow(park2)), breaks = 10, labels = FALSE)
folds
cv <- function(data, model){
# Randomly shuffle the data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds_
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fit <- lm(model, data=trainData)
EMSE <- mean((data$motor_UPDRS - predict.lm(model, newdata = testData))^2)
EMSE
}
}
cv(park, motor_UPDRS~.)
cv(park, motor_UPDRS~PPE)
testData <- park2[testIndexes, ]
testIndexes <- which(folds==i, arr.ind=TRUE)
testIndexes <- which(folds==1, arr.ind=TRUE)
testData <- data[testIndexes, ]
testData <- data[testIndexes]
testData <- park2[testIndexes, ]
testData
trainData = park2[-testIndexes, ]
trainData
lm.fit <- lm(motor_UPDRS~PPE, data=trainData)
lm.fit
predict(lm.fit, data=testData)
park2$motor_UPDRS
park2$motor_UPDRS - predict(lm.fit, data=testData)
length(park2$motor_UPDRS)
length(testData)
length(lm.fit)
length(predict(lm.fit, data=testData))
max(2,4)
min(2.4)
min(2,4)
predict.lm(motor_UPDRS~PPE, newdata = testData)
cv <- function(data, model){
# Randomly shuffle the data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds_
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fit <- lm(model, data=trainData)
EMSE <- mean((data$motor_UPDRS - predict(lm.fit, newdata = testData))^2)
EMSE
}
}
cv(park, motor_UPDRS~PPE)
newY <- sample(data$motor_UPDRS, length(lm.fit))
newY <- sample(park2$motor_UPDRS, length(lm.fit))
length(newY)
newY <- sample(park2$motor_UPDRS, length(predict(lm.fit, newData = testData))
exit
newY <- sample(park2$motor_UPDRS, length(predict(lm.fit, newData = testData)))
length(newY)
cv <- function(data, model){
# Randomly shuffle the data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds_
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fit <- lm(model, data=trainData)
newY <- sample(data$motor_UPDRS, length(predict(lm.fit, newData = testData)))
EMSE <- mean((data$motor_UPDRS - predict(lm.fit, newdata = testData))^2)
EMSE
}
}
cv(park, motor_UPDRS~PPE)
newY - predict(lm.fit, data=testData)
mean(newY - predict(lm.fit, newdata = testData))
cv <- function(data, model){
# Randomly shuffle the data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds_
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fit <- lm(model, data=trainData)
# newY <- sample(data$motor_UPDRS, length(predict(lm.fit, newData = testData)))
EMSE <- mean((data$motor_UPDRS - predict(lm.fit, newdata = testData))^2)
print(EMSE)
}
}
cv(park, motor_UPDRS~PPE)
cv <- function(data, model){
# Randomly shuffle the data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds_
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
EMSE = 0
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fit <- lm(model, data=trainData)
# newY <- sample(data$motor_UPDRS, length(predict(lm.fit, newData = testData)))
EMSE <- mean((data$motor_UPDRS - predict(lm.fit, newdata = testData))^2)
}
return(EMSE)
}
AMSE <- cv(park, motor_UPDRS~PPE)
AMSE
plot(lm.fit)
exit
plot(predict(lm.fit, newData=testData))
plot(data$motor_UPDRS, predict(lm.fit, newData=testData))
plot(park2$motor_UPDRS, predict(lm.fit, newData=testData))
AMSE2 <- cv(park, motor_UPDRS~PPE+'')
ff = regsubsets(formula, data=park, method="forward")
summary(ff)
AMSE2 <- cv(park, motor_UPDRS~PPE+DFA)
AMSE2
glm.fit = glm(motor_UPDRS~PPE, data=park)
cv.glm(park, glm.fit, K=10)$delta
glm.fit2 = glm(motor_UPDRS~PPE+DFA, data=park)
cv.glm(park, glm.fit2, K=10)$delta
glm.fit2 = glm(motor_UPDRS~PPE+DFA+Shimmer.APQ3, data=park)
glm.fit2 = glm(motor_UPDRS~PPE+DFA, data=park)
glm.fit3 = glm(motor_UPDRS~PPE+DFA+Shimmer.APQ3, data=park)
cv.glm(park, glm.fit3, K=10)$delta
AMSE3 <- cv(park, motor_UPDRS~PPE+DFA+Shimmer.APQ3)
AMSE3
plot(AMSE3)
cv <- function(data, model){
# Shuffle data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds)
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
EMSE = 0
mse_vec <- c(0)
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fit <- lm(model, data=trainData)
MSE <- mean((data$motor_UPDRS - predict(lm.fit, newdata = testData))^2)
mse_vec[i] = MSE
}
return(mse_vec)
}
AMSE <- cv(park, motor_UPDRS~PPE)
AMSE
plot(AMSE)
ff = regsubsets(formula, data=park, method="forward")
summary(ff)
cv10f <- function(data, model){
# Shuffle data
data<-data[sample(nrow(data)),]
# Create 10 equally sized groups (folds)
folds <- cut(seq(1,nrow(data)),breaks=10,labels=FALSE)
# Perform 10-fold cross validation
EMSE = 0
mse_vec <- c(0)
for(i in 1:10){
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
lm.fit <- lm(model, data=trainData)
MSE <- mean((data$motor_UPDRS - predict(lm.fit, newdata = testData))^2)
mse_vec[i] = MSE
}
return(mean(mse_vec))
}
formula <- as.formula((paste("motor_UPDRS~",paste(colnames(park[7:22]),collapse="+"))))
amse_vec <- c(0)
amse[1] = cv10f(park, motor_UPDRS~PPE)
amse[2] = cv10f(park, motor_UPDRS~PPE+DFA)
amse_vec[1] = cv10f(park, motor_UPDRS~PPE)
amse_vec[2] = cv10f(park, motor_UPDRS~PPE+DFA)
amse_vec[4] = cv10f(park, motor_UPDRS~PPE+DFA+Jitter.Abs+HNR)
amse_vec[8] = cv10f(park, motor_UPDRS~PPE+DFA+Jitter.Abs+HNR+NHR+Jitter...+Shimmer.DDA+Shimmer.APQ11)
amse_vec[16] = cv10f(park, formula)
amse_vec[4] = cv10f(park, motor_UPDRS~PPE+DFA+Jitter.Abs.+HNR)
amse_vec[8] = cv10f(park, motor_UPDRS~PPE+DFA+Jitter.Abs.+HNR+NHR+Jitter...+Shimmer.DDA+Shimmer.APQ11)
plot(amse_vec)
plot(amse_vec, xlab="number regression terms included", ylab="MSE")
plot(amse_vec, main=Parkinson's: 10-fold Cross-validation, ' xlab="number regression terms included", ylab="MSE")
plot(amse_vec, main="Parkinson's: 10-fold Cross-validation," xlab="number regression terms included", ylab="MSE")
plot(amse_vec, main="Parkinson\'s: 10-fold Cross-validation," xlab="number regression terms included", ylab="MSE")
plot(amse_vec, main="Parkinsons: 10-fold Cross-validation," xlab="number regression terms included", ylab="MSE")
plot(amse_vec, main="Parkinsons: 10-fold Cross-validation," xlab="number regression terms included", ylab="MSE")
plot(amse_vec, main="Parkinsons: 10-fold Cross-validation," xlab="number regression terms included", ylab="MSE")
plot(amse_vec, xlab="number regression terms included", ylab="MSE")
plot(amse_vec, xlab="number regression terms included", ylab="MSE")
plot(amse_vec, xlab="number regression terms included", ylab="MSE", main="Parkinsons: 10-fold Cross-validation," )
plot(amse_vec, xlab="number regression terms included", ylab="MSE", main="Parkinsons: 10-fold Cross-validation" )
lines(x, f_x, xlim=range(x), ylim=range(f_x), pch=16)
vec <- c(0)
glm1 <- glm.fit(motor_UPDRS~PPE, data=park)
glm1 <- glm(motor_UPDRS~PPE, data=park)
glm2 <- glm(motor_UPDRS~PPE+DFA, data=park)
glm4 <- glm(motor_UPDRS~PPE+DFA+Jitter.Abs.+HNR, data=park)
glm8 <- glm(motor_UPDRS~PPE+DFA+Jitter.Abs.+HNR+NHR+Jitter...+Shimmer.DDA+Shimmer.APQ11, data=park)
glm16 <- glm(formula, data=park)
vec[1] = cv.glm(park, glm1, K=10)$delta[1]
vec[2] = cv.glm(park, glm2, K=10)$delta[1]
vec[1]
vec[2]
vec[4] = cv.glm(park, glm4, K=10)$delta[1]
vec[8] = cv.glm(park, glm8, K=10)$delta[1]
vec[16] = cv.glm(park, glm16, K=10)$delta[1]
plot(vec, xlab="number regression terms included", ylab="MSE")
vec[1] = cv.glm(park, glm1, K=10)$delta[2]
vec[2] = cv.glm(park, glm2, K=10)$delta[2]
vec[4] = cv.glm(park, glm4, K=10)$delta[2]
vec[8] = cv.glm(park, glm8, K=10)$delta[2]
vec[16] = cv.glm(park, glm16, K=10)$delta[2]
plot(vec, xlab="number regression terms included", ylab="MSE")
>
plot(vec, xlab="number regression terms included", ylab="MSE", main="Parkinsons: 10-fold Cross-validation")
fix(park)
